{"version":3,"sources":["map-layers/binary-dfsu-layer-vertex.glsl.ts","map-layers/binary-dfsu-layer-fragment.glsl.ts","map-layers/BinaryDfsuLayer.jsx","store/root.ts","Legend.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["getVertexShader","numBands","fragmentShader","mouseX","window","addEventListener","e","x","y","BinaryDfsuLayer","this","props","colorPoints","length","vs","fs","getFragmentShader","modules","project","project32","picking","noAlloc","getAttributeManager","add","positions","size","type","GL","FLOAT","fp64","use64bitPositions","update","attribute","value","state","mesh","dfs_values_a","dfs_values_b","_createMesh","setState","_getCoordinateUniforms","oldProps","changeFlags","extensionsChanged","gl","context","model","delete","_getModel","invalidateAll","attributeManager","dfsValuesBufferA","dfsValuesBufferB","invalidate","getShaders","_imageCoordinateSystem","disablePicking","verticesBuffer","vertexCount","Model","Object","assign","id","geometry","Geometry","drawMode","TRIANGLES","isInstanced","opts","uniforms","moduleParameters","pickingActive","colorBandUniforms","forEach","colorPoint","index","convertStringToColor","color","generalUniforms","screenWidth","innerWidth","setUniforms","draw","coordinateConversion","Layer","rgbString","includes","convertRgbaStringToNumber","convertRgbStringToNumber","rgbaString","values","replace","split","parseInt","Math","round","parseFloat","layerName","zip","useWebWorkers","RootStore","isLoaded","binaryDfsuLayer","colorAttributeBuffers","colorAttributeBufferEmpty","_currentTimestepIndex","timestepDateTimes","minDFSValue","maxDFSValue","legendScale","mouseY","fetchAnalysisTimesteps","flow","fetch","method","headers","Accept","response","blob","console","error","retrieveTimeSteps","densityBlob","extractDataFromBlob","currentTimestepIndex","renderDfsuLayer","reader","getEntries","entries","verticesIndex","findIndex","entry","filename","zipEntryToBuffer","statsIndex","zipEntryToJSON","stats","dateTimes","map","dateTime","Date","buffers","i","bufferIndex","buffer","attribBuffer","dfsValuesToColorBuffer","push","Float32Array","generateLegendColorPoints","close","getData","data","arrayBuffer","text","jsonText","json","JSON","parse","makeAutoObservable","attribBufferIndex","attribBufferB","toJS","parameters","depthTest","dfsValuesBuffer","attributeBuffer","j","currentModulosIndex","modulos","currScale","numIntervalsToMin","floor","ceil","modulo","startingInterval","endingInterval","scaleColors","scaleLinear","domain","range","interpolate","d3","label","StoreReactContext","createContext","undefined","useStore","useContext","Error","Legend","observer","Box","width","display","height","mr","style","backgroundColor","Typography","variant","component","INITIAL_VIEW_STATE","longitude","latitude","zoom","pitch","bearing","App","store","React","useEffect","currentTime","prevTime","intervalId","setInterval","now","performance","delta","endIndex","currIndex","clearInterval","layers","initialViewState","controller","_animate","position","left","top","borderRadius","p","minWidth","bottom","transform","Slider","min","max","onChange","event","newValue","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Root","useState","StrictMode","Provider","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.39c5e2fd.chunk.js","sourcesContent":["const getVertexShader = (numBands: number) => `\r\n#define SHADER_NAME bitmap-layer-vertex-shader\r\n\r\nstruct ColorBand {\r\n  float value;\r\n  vec4 color;\r\n};\r\n\r\nattribute vec3 positions;\r\nattribute float dfs_values_a;\r\nattribute float dfs_values_b;\r\n\r\nvarying float dfs_value_a;\r\nvarying float dfs_value_b;\r\n\r\nvoid main(void) {\r\n  dfs_value_a = dfs_values_a;\r\n  dfs_value_b = dfs_values_b;\r\n  vec3 center = project_position(positions);\r\n  // center.z = center.z + dfs_value_a * 0.001;\r\n  gl_Position = project_common_position_to_clipspace(vec4(center, 1.0));\r\n}\r\n`;\r\n\r\nexport default getVertexShader;\r\n","const fragmentShader = (numBands: number) => `\r\n#define SHADER_NAME bitmap-layer-fragment-shader\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nstruct ColorBand {\r\n  float value;\r\n  vec4 color;\r\n};\r\n\r\nvarying float dfs_value_a;\r\nvarying float dfs_value_b;\r\n\r\nuniform ColorBand colorBands[${numBands}];\r\nuniform float screenWidth;\r\nuniform float mouseX;\r\n\r\nvec4 valueToColor(float value) {\r\n  vec4 outColor = vec4(0.0);\r\n  for (int i = 0; i < ${numBands}; ++i) {\r\n    float interpolatePt = (value - colorBands[i].value) / (colorBands[i+1].value - colorBands[i].value);\r\n    outColor = mix(colorBands[i].color, colorBands[i+1].color, interpolatePt);\r\n\r\n    if (value <= colorBands[i+1].value) {\r\n      break;\r\n    }\r\n  }\r\n  return outColor;\r\n}\r\n\r\nvoid main(void) {\r\n  float mousePosX = (screenWidth - (screenWidth - mouseX));\r\n\r\n  if (gl_FragCoord.x > mousePosX) {\r\n    gl_FragColor = valueToColor(dfs_value_a);\r\n  } else {\r\n    gl_FragColor = valueToColor(dfs_value_b);\r\n  }\r\n}\r\n`;\r\n\r\nexport default fragmentShader;\r\n","import GL from \"@luma.gl/constants\";\r\nimport { Layer, project, project32, picking } from \"@deck.gl/core\";\r\nimport { Model, Geometry } from \"@luma.gl/core\";\r\nimport getVertexShader from \"./binary-dfsu-layer-vertex.glsl.ts\";\r\nimport getFragmentShader from \"./binary-dfsu-layer-fragment.glsl.ts\";\r\n\r\nlet mouseX = 0;\r\nlet mouseY = 0;\r\n\r\nwindow.addEventListener('mousemove', e => {\r\n  mouseX = e.x;\r\n  mouseY = e.y;\r\n});\r\n\r\nexport default class BinaryDfsuLayer extends Layer {\r\n  getShaders() {\r\n    const numBands = this.props.colorPoints.length;\r\n    const vs = getVertexShader(numBands);\r\n    const fs = getFragmentShader(numBands);\r\n    return super.getShaders({ vs, fs, modules: [project, project32, picking] });\r\n  }\r\n\r\n  initializeState() {\r\n    const attributeManager = this.getAttributeManager();\r\n    const noAlloc = true;\r\n\r\n    attributeManager.add({\r\n      positions: {\r\n        size: 3,\r\n        type: GL.FLOAT,\r\n        fp64: this.use64bitPositions(),\r\n        update: (attribute) => (attribute.value = this.state.mesh.positions),\r\n        noAlloc,\r\n      },\r\n      dfs_values_a: {\r\n        size: 1,\r\n        type: GL.FLOAT,\r\n        update: (attribute) => (attribute.value = this.state.mesh.dfs_values_a),\r\n        noAlloc,\r\n      },\r\n      dfs_values_b: {\r\n        size: 1,\r\n        type: GL.FLOAT,\r\n        update: (attribute) => (attribute.value = this.state.mesh.dfs_values_b),\r\n        noAlloc,\r\n      },\r\n    });\r\n\r\n    const mesh = this._createMesh();\r\n    this.setState({ \r\n      mesh, \r\n      ...this._getCoordinateUniforms()\r\n    });\r\n  }\r\n\r\n  updateState({ props, oldProps, changeFlags }) {\r\n    // setup model first\r\n    if (changeFlags.extensionsChanged) {\r\n      const { gl } = this.context;\r\n      if (this.state.model) {\r\n        this.state.model.delete();\r\n      }\r\n      this.setState({ model: this._getModel(gl) });\r\n      this.getAttributeManager().invalidateAll();\r\n    }\r\n\r\n    const attributeManager = this.getAttributeManager();\r\n\r\n    if ((props.dfsValuesBufferA !== oldProps.dfsValuesBufferA) || (props.dfsValuesBufferB !== oldProps.dfsValuesBufferB)) {\r\n      const mesh = this._createMesh();\r\n      attributeManager.invalidate(\"dfs_values_a\");\r\n      attributeManager.invalidate(\"dfs_values_b\");\r\n      this.setState({ mesh });\r\n    }\r\n\r\n    if (props.colorPoints !== oldProps.colorPoints) {\r\n      this.getShaders();\r\n    }\r\n\r\n    if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\r\n      this.setState(this._getCoordinateUniforms());\r\n    }\r\n  }\r\n\r\n  // Override base Layer multi-depth picking logic\r\n  disablePickingIndex() {\r\n    this.setState({ disablePicking: true });\r\n  }\r\n\r\n  restorePickingColors() {\r\n    this.setState({ disablePicking: false });\r\n  }\r\n\r\n  _createMesh() {\r\n    const { verticesBuffer, dfsValuesBufferA, dfsValuesBufferB } = this.props;\r\n\r\n    return {\r\n      vertexCount: verticesBuffer.length / 3,\r\n      positions: verticesBuffer,\r\n      dfs_values_a: dfsValuesBufferA,\r\n      dfs_values_b: dfsValuesBufferB,\r\n    };\r\n  }\r\n\r\n  _getModel(gl) {\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    return new Model(\r\n      gl,\r\n      Object.assign({}, this.getShaders(), {\r\n        id: this.props.id,\r\n        geometry: new Geometry({\r\n          drawMode: GL.TRIANGLES,\r\n          vertexCount: this.props.verticesBuffer.length / 3,\r\n        }),\r\n        isInstanced: false,\r\n      })\r\n    );\r\n  }\r\n\r\n  draw(opts) {\r\n    const { uniforms, moduleParameters } = opts;\r\n    const { model, disablePicking } = this.state;\r\n\r\n    if (moduleParameters.pickingActive && disablePicking) {\r\n      return;\r\n    }\r\n\r\n    const colorBandUniforms = {};\r\n    this.props.colorPoints.forEach((colorPoint, index) => {\r\n      colorBandUniforms[`colorBands[${index}].value`] = colorPoint.value;\r\n      colorBandUniforms[`colorBands[${index}].color`] = convertStringToColor(\r\n        colorPoint.color\r\n      );\r\n    });\r\n\r\n    const generalUniforms = {\r\n      screenWidth: window.innerWidth,\r\n      mouseX: mouseX,\r\n    };\r\n\r\n    // Render the image\r\n    if (model) {\r\n      model\r\n        .setUniforms({uniforms, ...colorBandUniforms, ...generalUniforms })\r\n        .draw();\r\n    }\r\n  }\r\n\r\n  _getCoordinateUniforms() {\r\n    return {\r\n      coordinateConversion: 0,\r\n    };\r\n  }\r\n}\r\n\r\nconst convertStringToColor = (rgbString) => {\r\n  if (rgbString.includes(\"rgba(\")) {\r\n    return convertRgbaStringToNumber(rgbString);\r\n  } else {\r\n    return convertRgbStringToNumber(rgbString);\r\n  }\r\n};\r\n\r\nconst convertRgbaStringToNumber = (rgbaString) => {\r\n  const values = rgbaString\r\n    .replace(\" \", \"\")\r\n    .replace(\"rgba(\", \"\")\r\n    .replace(\")\", \"\")\r\n    .split(\",\");\r\n  const r = parseInt(values[0]) / 255.0;\r\n  const g = parseInt(values[1]) / 255.0;\r\n  const b = parseInt(values[2]) / 255.0;\r\n  const a = Math.round(parseFloat(values[3]) * 255) / 255.0;\r\n\r\n  return [r, g, b, a];\r\n};\r\n\r\nconst convertRgbStringToNumber = (rgbString) => {\r\n  const values = rgbString\r\n    .replace(\" \", \"\")\r\n    .replace(\"rgb(\", \"\")\r\n    .replace(\")\", \"\")\r\n    .split(\",\");\r\n  const r = parseInt(values[0]) / 255.0;\r\n  const g = parseInt(values[1]) / 255.0;\r\n  const b = parseInt(values[2]) / 255.0;\r\n\r\n  return [r, g, b, 1.0];\r\n};\r\n\r\nBinaryDfsuLayer.layerName = \"BinaryGridLayer\";\r\n","import { flow, makeAutoObservable, toJS } from \"mobx\";\r\nimport { createContext, useContext } from \"react\";\r\nimport * as zip from \"@zip.js/zip.js\";\r\nimport * as d3 from \"d3-interpolate\";\r\nimport { scaleLinear } from \"d3-scale\";\r\nimport BinaryDfsuLayer from \"../map-layers/BinaryDfsuLayer\";\r\nimport { ColorPoint } from \"./types\";\r\n\r\nzip.configure({ useWebWorkers: false });\r\n\r\nexport class RootStore {\r\n  public isLoaded: boolean;\r\n\r\n  // DFSU Layer.\r\n  public binaryDfsuLayer: BinaryDfsuLayer | null;\r\n\r\n  // Shader GLSL Attributes.\r\n  public verticesBuffer: Float32Array | null;\r\n  public colorAttributeBuffers: Float32Array[];\r\n  public colorAttributeBufferEmpty: Float32Array | null;\r\n\r\n  // Timeline\r\n  private _currentTimestepIndex: number;\r\n  public timestepDateTimes: Date[];\r\n\r\n  // Legend.\r\n  public minDFSValue: number;\r\n  public maxDFSValue: number;\r\n  public legendScale: ColorPoint[];\r\n\r\n  public mouseX: number;\r\n  public mouseY: number;\r\n\r\n  constructor() {\r\n    makeAutoObservable(this);\r\n\r\n    this.binaryDfsuLayer = null;\r\n    this.verticesBuffer = null;\r\n    this.colorAttributeBuffers = [];\r\n    this.timestepDateTimes = [];\r\n    this._currentTimestepIndex = -1;\r\n    this.colorAttributeBufferEmpty = null;\r\n    this.isLoaded = false;\r\n    this.minDFSValue = 0;\r\n    this.maxDFSValue = 0;\r\n    this.legendScale = [];\r\n    this.mouseX = 0;\r\n    this.mouseY = 0;\r\n  }\r\n\r\n  public get currentTimestepIndex() {\r\n    return this._currentTimestepIndex;\r\n  }\r\n\r\n  public set currentTimestepIndex(index: number) {\r\n    this._currentTimestepIndex = index;\r\n    if (index >= 0) {\r\n      this.renderDfsuLayer();\r\n    }\r\n  }\r\n\r\n  public fetchAnalysisTimesteps = flow(function* (this: RootStore) {\r\n    try {\r\n      const response: Response = yield fetch(\"./timesteps.zip\", {\r\n        method: \"GET\",\r\n        headers: {\r\n          Accept: \"application/x-zip-compressed\",\r\n        },\r\n      });\r\n\r\n      const blob = yield response.blob();\r\n      return blob;\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  });\r\n\r\n  public retrieveTimeSteps = flow(function* (this: RootStore) {\r\n    const densityBlob = yield this.fetchAnalysisTimesteps();\r\n\r\n    if (!densityBlob) {\r\n      return;\r\n    }\r\n    yield this.extractDataFromBlob(densityBlob);\r\n\r\n    this.currentTimestepIndex = 0;\r\n    this.renderDfsuLayer();\r\n    this.isLoaded = true;\r\n  });\r\n\r\n  public renderDfsuLayer() {\r\n    let attribBufferIndex;\r\n    if (!this.isLoaded) {\r\n      attribBufferIndex = 0;\r\n    } else {\r\n      attribBufferIndex = this.currentTimestepIndex;\r\n    }\r\n\r\n    let attribBuffer: Float32Array | null;\r\n    if (attribBufferIndex !== -1) {\r\n      attribBuffer = this.colorAttributeBuffers[attribBufferIndex];\r\n    } else {\r\n      attribBuffer = this.colorAttributeBufferEmpty;\r\n    }\r\n\r\n    let attribBufferB = new Float32Array(attribBuffer!.length)\r\n    for (let i = 0; i < attribBuffer!.length; ++i) {\r\n      attribBufferB[i] = attribBuffer![i] / 3.0;\r\n    }\r\n\r\n    this.binaryDfsuLayer = new BinaryDfsuLayer({\r\n      id: \"Example Binary Grid Layer\",\r\n      verticesBuffer: this.verticesBuffer,\r\n      dfsValuesBufferA: attribBuffer,\r\n      dfsValuesBufferB: attribBufferB,\r\n      colorPoints: toJS(this.legendScale),\r\n      parameters: { depthTest: false },\r\n    } as any);\r\n  }\r\n\r\n  private extractDataFromBlob = flow(function* (this: RootStore, blob: Blob) {\r\n    const reader = new zip.ZipReader(new zip.BlobReader(blob));\r\n    const entries: zip.Entry[] = yield reader.getEntries();\r\n\r\n    if (entries.length) {\r\n      const verticesIndex = entries.findIndex(\r\n        (entry) => entry.filename === \"vertices.bin\"\r\n      );\r\n      const positions = yield this.zipEntryToBuffer(entries, verticesIndex);\r\n\r\n      const statsIndex = entries.findIndex(\r\n        (entry) => entry.filename === \"stats.json\"\r\n      );\r\n      const stats = yield this.zipEntryToJSON(entries, statsIndex);\r\n\r\n      this.timestepDateTimes = stats.dateTimes.map(\r\n        (dateTime: string) => new Date(dateTime)\r\n      );\r\n\r\n      const buffers = [];\r\n      for (let i = 0; i < entries.length - 2; ++i) {\r\n        const bufferIndex = entries.findIndex(\r\n          (entry) => entry.filename === `${i}.bin`\r\n        );\r\n        const buffer = yield this.zipEntryToBuffer(entries, bufferIndex);\r\n\r\n        const attribBuffer = this.dfsValuesToColorBuffer(buffer);\r\n        buffers.push(attribBuffer);\r\n\r\n        if (i === 0) {\r\n          this.colorAttributeBufferEmpty = new Float32Array(\r\n            attribBuffer.length\r\n          );\r\n        }\r\n      }\r\n\r\n      this.verticesBuffer = positions;\r\n      this.colorAttributeBuffers = buffers;\r\n      this.minDFSValue = 0.0;\r\n      this.maxDFSValue = 12.0;\r\n      this.legendScale = this.generateLegendColorPoints();\r\n    }\r\n\r\n    yield reader.close();\r\n  });\r\n\r\n  private zipEntryToBuffer = flow(function* (\r\n    this: RootStore,\r\n    entries: zip.Entry[],\r\n    index: number\r\n  ) {\r\n    const entry = entries[index] as any;\r\n    const data = yield entry.getData(new zip.BlobWriter());\r\n    const arrayBuffer = yield data.arrayBuffer();\r\n    return new Float32Array(arrayBuffer);\r\n  });\r\n\r\n  private zipEntryToJSON = flow(function* (\r\n    this: RootStore,\r\n    entries: zip.Entry[],\r\n    index: number\r\n  ) {\r\n    const entry = entries[index] as any;\r\n    const data = yield entry.getData(new zip.BlobWriter());\r\n    const jsonText = yield data.text();\r\n    const json = JSON.parse(jsonText);\r\n    return json;\r\n  });\r\n\r\n  private dfsValuesToColorBuffer(dfsValuesBuffer: Float32Array): Float32Array {\r\n    const attributeBuffer = new Float32Array(dfsValuesBuffer.length * 3);\r\n    let j = 0;\r\n    for (let i = 0; i < dfsValuesBuffer.length; ++i) {\r\n      const value = dfsValuesBuffer[i];\r\n      attributeBuffer[j++] = value;\r\n      attributeBuffer[j++] = value;\r\n      attributeBuffer[j++] = value;\r\n    }\r\n    return attributeBuffer;\r\n  }\r\n\r\n  public generateLegendColorPoints() {\r\n    let currentModulosIndex = 0;\r\n    let modulos = [\r\n      1, 2, 5, 10, 15, 20, 25, 50, 100, 150, 200, 250, 300, 400, 500, 1000,\r\n      2000, 5000, 10000, 20000, 25000, 50000, 100000, 200000, 250000, 500000,\r\n    ];\r\n    while (currentModulosIndex < modulos.length) {\r\n      const currScale = modulos[currentModulosIndex];\r\n      const numIntervalsToMin = Math.floor(this.minDFSValue / currScale);\r\n      const numIntervalsToMax = Math.ceil(this.maxDFSValue / currScale) + 1;\r\n      if (numIntervalsToMax - numIntervalsToMin > 10) {\r\n        currentModulosIndex++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    const modulo = modulos[currentModulosIndex];\r\n    const colorPoints: ColorPoint[] = [];\r\n    const startingInterval = Math.floor(this.minDFSValue / modulo);\r\n    const endingInterval = Math.ceil(this.maxDFSValue / modulo) + 1;\r\n\r\n    const scaleColors = scaleLinear()\r\n      .domain([\r\n        startingInterval,\r\n        (startingInterval + endingInterval) * 0.25,\r\n        (startingInterval + endingInterval) * 0.5,\r\n        (startingInterval + endingInterval) * 0.75,\r\n        endingInterval,\r\n      ])\r\n      .range([\r\n        \"#211fccaa\",\r\n        \"#438ba1cc\",\r\n        \"#edea37cc\",\r\n        \"#eb9c2fcc\",\r\n        \"#c91818cc\",\r\n      ] as any)\r\n      .interpolate(d3.interpolateHsl as any);\r\n\r\n    for (let i = startingInterval; i < endingInterval; ++i) {\r\n      const value = i * modulo;\r\n\r\n      colorPoints.push({\r\n        value,\r\n        color: scaleColors(i) as any,\r\n        label: `${value}`,\r\n      });\r\n    }\r\n\r\n    return colorPoints;\r\n  }\r\n\r\n  public updateMouse(x: number, y: number) {\r\n    this.mouseX = x;\r\n    this.mouseY = y;\r\n  }\r\n}\r\n\r\nexport const StoreReactContext = createContext<RootStore | undefined>(\r\n  undefined\r\n);\r\n\r\nexport function useStore() {\r\n  return (\r\n    useContext(StoreReactContext) ??\r\n    (() => {\r\n      throw new Error(\"RootStoreReactContext missing.\");\r\n    })()\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Box from \"@material-ui/core/Box\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport { observer } from \"mobx-react-lite\";\r\nimport { useStore } from \"./store/root\";\r\nimport { ColorPoint } from \"./store/types\";\r\n\r\nconst Legend: React.FC<{}> = observer(() => {\r\n  const { legendScale } = useStore();\r\n\r\n  return (\r\n    <Box width=\"15ch\">\r\n      {legendScale.map((colorPoint: ColorPoint) => (\r\n        <Box key={colorPoint.label}>\r\n          <Box\r\n            display=\"inline-block\"\r\n            width=\"0.8rem\"\r\n            height=\"0.8rem\"\r\n            mr={1}\r\n            style={{ backgroundColor: colorPoint.color }}\r\n          ></Box>\r\n          <Typography variant=\"overline\" component=\"span\">\r\n            {colorPoint.label}\r\n          </Typography>\r\n        </Box>\r\n      ))}\r\n    </Box>\r\n  );\r\n});\r\n\r\nexport default Legend;\r\n","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport \"./App.css\";\nimport DeckGL from \"@deck.gl/react\";\nimport { BitmapLayer } from \"@deck.gl/layers\";\nimport { TileLayer } from \"@deck.gl/geo-layers\";\nimport { useStore } from \"./store/root\";\nimport Legend from \"./Legend\";\nimport Box from \"@material-ui/core/Box\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Slider from \"@material-ui/core/Slider\";\n\nconst INITIAL_VIEW_STATE = {\n  longitude: 153.126,\n  latitude: -27.4105,\n  zoom: 11,\n  pitch: 0,\n  bearing: 0,\n};\n\nconst App = observer(() => {\n  const store = useStore();\n\n  React.useEffect(() => {\n    store.retrieveTimeSteps();\n  }, [store]);\n\n  React.useEffect(() => {\n    let currentTime = 0;\n    let prevTime = currentTime;\n\n    const animateFn = () => {\n      const now = performance.now();\n      const delta = now - prevTime;\n      prevTime = now;\n      currentTime = currentTime + delta;\n\n      const endIndex = store.timestepDateTimes.length - 1;\n      const currIndex = store.currentTimestepIndex;\n\n      if (currIndex < endIndex && currIndex !== -1) {\n        store.currentTimestepIndex = currIndex + 1;\n      } else {\n        store.currentTimestepIndex = -1;\n      }\n    };\n\n    const intervalId = setInterval(animateFn, 40);\n\n    return () => clearInterval(intervalId);\n  }, [store]);\n\n  const handleTimestepChangeCommit = (\n    event: any,\n    newValue: number | number[]\n  ) => {\n    store.currentTimestepIndex = newValue as number;\n  };\n\n  const layers: any[] = []; //renderTileLayer()];\n  if (store.isLoaded && store.binaryDfsuLayer) {\n    layers.push(store.binaryDfsuLayer);\n  }\n\n  return (\n    <div style={{backgroundColor: '#0f0f0f'}}>\n      <DeckGL\n        initialViewState={INITIAL_VIEW_STATE}\n        controller={true}\n        layers={layers}\n        _animate\n      />\n      {store.isLoaded && (\n        <Box\n          position=\"absolute\"\n          left=\"1rem\"\n          top=\"1rem\"\n          borderRadius=\"0.5rem\"\n          p={2}\n          style={{ backgroundColor: \"white\" }}\n        >\n          <Legend />\n        </Box>\n      )}\n      {!store.isLoaded && (\n        <Box\n          position=\"absolute\"\n          left=\"1rem\"\n          top=\"1rem\"\n          borderRadius=\"0.5rem\"\n          minWidth=\"20ch\"\n          p={2}\n          style={{ backgroundColor: \"white\" }}\n        >\n          <Typography>Loading...</Typography>\n        </Box>\n      )}\n      {store.isLoaded && (\n        <Box\n          position=\"absolute\"\n          left=\"50%\"\n          bottom=\"1rem\"\n          borderRadius=\"0.5rem\"\n          minWidth=\"50ch\"\n          p={2}\n          style={{ backgroundColor: \"white\", transform: \"translateX(-50%)\" }}\n        >\n          <Slider\n            value={store.currentTimestepIndex > 0 ? store.currentTimestepIndex : 0}\n            min={0}\n            max={store.timestepDateTimes.length - 1}\n            onChange={handleTimestepChangeCommit}\n          />\n        </Box>\n      )}\n    </div>\n  );\n});\n\nconst renderTileLayer = () =>\n  new TileLayer({\n    data: \"https://c.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    minZoom: 0,\n    maxZoom: 19,\n    tileSize: 256,\n\n    renderSubLayers: (props) => {\n      const {\n        bbox: { west, south, east, north },\n      } = props.tile;\n\n      return new BitmapLayer(props, {\n        data: null,\n        image: props.data,\n        bounds: [west, south, east, north],\n      });\n    },\n  });\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { RootStore, StoreReactContext } from \"./store/root\";\n\nfunction Root() {\n  const [store, setStore] = React.useState<RootStore>(new RootStore());\n\n  return (\n    <React.StrictMode>\n      <StoreReactContext.Provider value={store}>\n        <App />\n      </StoreReactContext.Provider>\n    </React.StrictMode>\n  );\n}\n\nReactDOM.render(<Root />, document.getElementById(\"root\"));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}